package org.tbk.lightning.lnurl.example.lnurl;

import fr.acinq.bitcoin.ByteVector64;
import fr.acinq.bitcoin.Crypto;
import fr.acinq.secp256k1.Hex;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import org.apache.http.NameValuePair;
import org.apache.http.client.utils.URLEncodedUtils;
import org.tbk.lnurl.K1;
import org.tbk.lnurl.LnUrlAuth;
import org.tbk.lnurl.simple.SimpleK1;
import org.tbk.lnurl.simple.SimpleLnUrlAuth;
import scodec.bits.ByteVector;

import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Optional;

import static java.util.Objects.requireNonNull;

@Slf4j
public class SimpleLnAuthService implements LnAuthService {

    private final URI base;

    private final K1Manager k1Manager;

    @SneakyThrows
    public SimpleLnAuthService(URI domain, K1Manager k1Manager) {
        this.base = requireNonNull(domain);
        this.k1Manager = requireNonNull(k1Manager);
    }

    @Override
    public LnUrlAuth createLnUrlAuth() {
        K1 k1 = k1Manager.create();
        return SimpleLnUrlAuth.create(base, k1);
    }

    @Override
    public boolean verifyLogin(URI loginUri) {
        List<NameValuePair> params = URLEncodedUtils.parse(loginUri, StandardCharsets.UTF_8);

        NameValuePair k1Param = findFirstQueryParamOrThrow(params, "k1");

        K1 k1 = SimpleK1.fromHex(k1Param.getValue());
        boolean validK1 = k1Manager.isValid(k1);
        if (!validK1) {
            // throw new IllegalArgumentException("k1 value has either expired or was not generated by this service.");
            return false;
        }
        k1Manager.invalidate(k1);

        NameValuePair keyParam = findFirstQueryParamOrThrow(params, "key");
        NameValuePair sigParam = findFirstQueryParamOrThrow(params, "sig");

        ByteVector rawK1 = ByteVector.view(k1.data());
        ByteVector64 rawSig = Crypto.der2compact(ByteVector.view(Hex.decode(sigParam.getValue())));
        Crypto.PublicKey rawKey = new Crypto.PublicKey(ByteVector.view(Hex.decode(keyParam.getValue())));

        return Crypto.verifySignature(rawK1, rawSig, rawKey);
    }

    private NameValuePair findFirstQueryParamOrThrow(List<NameValuePair> params, String name) {
        return findFirstQueryParam(params, name).orElseThrow(() -> {
            String message = String.format("Cannot find param '%s' in query", name);
            return new IllegalStateException(message);
        });
    }

    private Optional<NameValuePair> findFirstQueryParam(List<NameValuePair> params, String name) {
        return params.stream()
                .filter(it -> it.getName().equals(name))
                .findFirst();
    }
}
